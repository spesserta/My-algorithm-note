# 找出最大公因数和最小公倍数算法<br>
## 一、求最大公因数有更相减损法和辗转相除法两种：<br>
### 1、更相减损法： <br>
  假设我们要求378和90两个数的最大公因数，将大的数字减去小的数字即378-90=288，在将结果和较小的数字相比较，再将大的数字减去小的数字，如此循环直到两数相等为止。<br>
  完整过程： 378-90=288 288-90=198 198-90=108 108-90=18 90-18=72 72-18=54 54-18=36 36-18=18 停止<br>
此时，相等的两个数18即为最大公因数。<br><br>
*算法实现：*
```c++
int Getmin(int x,int y) 
{
	int temp=0;
	while(x!=y)
	{
     if(x>y)
	   {
	      temp=x-y;
	      swap(x,temp);
	   }
	   else
	   {
	      temp=y-x; 
	      swap(y,temp);
      }
	}
	return y;
}
```

### 2、辗转相除法：<br>
改方法逻辑上和更相减损法相似，将大的数值除以小的数值得出一个余数，再用除数继续除以余数得出新余数，如此反复到余数为0停止，此时的除数就是最大公约数。<bt>
*算法实现：*<br>
```c++
int Getmin(int x,int y)
{
    int temp=x%y;    
    while(temp!=0)
{
 
        x=y; 
        y=temp;
        temp=x%y;
    }
    return y;  //返回y值
}
```
*短一点的递归算法*
```
int Getmin(int a,int b)
{
return b==0 ? a: Getmin(b,a%b);
}
```
## 二、求最小公倍数：<br>
### 1、不断从小到大枚举直到满足x%a==0 && x%b==0<br>
由于这样做时间复杂度高，需要进行一些优化。首先最小公倍数满足两个数的相同倍数，由此可知最小公倍数是大于两个数的，这样就不需要从1开始不断枚举了;其次最小公倍数可以从其中一个倍数开始不断列举它的所有倍数，直到满足为另一个数的倍数这一条件即可。再优化一点就是从2个数中找出更大的，列举它的所有公倍数。<br>
*算法实现：*<br><br>
```c++
int Getmax(int a,int b)
{
	int max=a>b?a:b;
	int n=max;
	while(1)
	{
		if(n%a==0&&n%b==0)
		 break;
	    n+=max;
	}
	return n;
}
