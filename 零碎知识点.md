# 零碎知识点总结
## 1、闰年分为普通闰年和世纪闰年，普通闰年能被4整除且不能被100整除，世纪闰年能被100和400同时整除。<br>
 普通闰年判断：<br>
```c++
if(a%4==0&&a%100!=0)
```
 世纪闰年判断：<br>
```c++
if(a%100==0&&a%400==0)
```
## 2、取整问题：<br>
 >取整问题可以分成三类：向上取整、向下取整、四舍五入，可以通过自己编写代码或者调用函数得到<br>
 不调用任何函数的取整方法：<br>
 ```c++
(int)(a+1) //单一变量取整
if(a%b==0) result=a/b; //表达式的结果取整
else result=a/b+1
```
调用取整函数：<br>
```c++
//向下取整用强制转换即可
(int)(9.77)为9
//向上取整用std::ceil(浮点数)
std::ceil(8.688)为9
//四舍五入取整用round(浮点数)
round(3.4)为3
rounf(3.5)为4
```
## 3、在C++中除了或(||)、且(&&)、非(!)这三个逻辑运算符，还有异或(^)运算符，当只有满足一个为真一个为假的条件时才能为真。
```c++
bool a=true,b=true,c=false,d=false;
//a^b为false
//a^c为true
//c^d为false
```
## 4、数字的倒序
```c++
int rev(int x){
	int ret=0;  //翻转后的数字 
	while(x){
		ret=ret*10+x%10; //每次循环ret乘10，然后再加上x的余数 
		x/=10;   //x取完余数后再往前进一位 
	}
	return ret;
}
int
```
## 5、找出最大公因数和最小公倍数算法<br>
### 5.1、求最大公因数有更相减损法和辗转相除法两种：<br>
#### 5.1.1、更相减损法： <br>
  假设我们要求378和90两个数的最大公因数，将大的数字减去小的数字即378-90=288，在将结果和较小的数字相比较，再将大的数字减去小的数字，如此循环直到两数相等为止。<br>
  完整过程： 378-90=288 288-90=198 198-90=108 108-90=18 90-18=72 72-18=54 54-18=36 36-18=18 停止<br>
此时，相等的两个数18即为最大公因数。<br><br>
*算法实现：*
```c++
int Getmin(int x,int y) 
{
	int temp=0;
	while(x!=y)
	{
     if(x>y)
	   {
	      temp=x-y;
	      swap(x,temp);
	   }
	   else
	   {
	      temp=y-x; 
	      swap(y,temp);
      }
	}
	return y;
}
```

#### 5.1.2、辗转相除法：<br>
改方法逻辑上和更相减损法相似，将大的数值除以小的数值得出一个余数，再用除数继续除以余数得出新余数，如此反复到余数为0停止，此时的除数就是最大公约数。<bt>
*算法实现：*<br>
```c++
int Getmin(int x,int y)
{
    int temp=x%y;    
    while(temp!=0)
{
 
        x=y; 
        y=temp;
        temp=x%y;
    }
    return y;  //返回y值
}
```
*短一点的递归算法*
```
int Getmin(int a,int b)
{
return b==0 ? a: Getmin(b,a%b);
}
```
### 5.2、求最小公倍数：<br>
#### 5.2.1、不断从小到大枚举直到满足x%a==0 && x%b==0<br>
由于这样做时间复杂度高，需要进行一些优化。首先最小公倍数满足两个数的相同倍数，由此可知最小公倍数是大于两个数的，这样就不需要从1开始不断枚举了;其次最小公倍数可以从其中一个倍数开始不断列举它的所有倍数，直到满足为另一个数的倍数这一条件即可。再优化一点就是从2个数中找出更大的，列举它的所有公倍数。<br>
*算法实现：*<br><br>
```c++
int Getmax(int a,int b)
{
	int max=a>b?a:b;
	int n=max;
	while(1)
	{
		if(n%a==0&&n%b==0)
		 break;
	    n+=max;
	}
	return n;
}
```
## 6、如果算法题需要往数组里面输入数字，但是输入的长度未知，可以尝试以下方法：<br>
首先把数组开到够大，然后:<br>
```c++
int num[100000];
int i=0,count=0;
while(cin>>num[i++]){  //重点
     count++;
	}
```
这样的话当输入到达末尾EOF时自动停止输入，在编译器里面可能无法调试，直接Ctr+z手动停止输入即可。<br>
