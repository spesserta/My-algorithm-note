# 递归
所谓递归就是函数自己调用自己，当然需要设置调用的终止条件。<br>
## 一、以求n的阶乘为例，n!=n*(n-1)！，一直扩展下去直到n=1时停止，用函数代码实现就是：<br>
```c++
int fun(int n){
   if(n==1) return 1;  //当n=1时候停止
   return n*fun(n-1);  //返回值为函数自己
}
```
>可以理解成这样：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/7e63e6bb-a8d5-414d-aeea-6017710b6fbe)<br>
>递归的图示：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/040c8e3b-963b-412a-8c2c-9389dfe48021)

## 二、以斐波那契为例：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/586a2bd0-60fe-45a6-80ea-411ebfacef51)
```c++
int fib(int n){
   if(n==1 || n==2) return 1;
   return fib(n-1)+fib(n-2);   //每种情况都是该元素的前两个元素之和
  }
```
>以fib(5)为例：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/372ce265-dd7d-4198-be76-fa558e42ee15)

## 三、已知一个数学分段函数，输出f(x)，这种题用递归比较容易。<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/e82161bd-fa70-4ecf-aba9-07991dd7add8)
```c++
#include<iostream>
using namespace std;

long long f(int x){
	if(x<=0) return 0;
	if(x==1) return 1;
	if(x>1&&x%2==0)  return 3*f(x/2)-1;
	if(x>1&&x%2==1)  return 3*f((x+1)/2)-1; 
}

int main(){
	int n;
	cin>>n;
	cout<<f(n);
	return 0;
}
```
## 四、改版的斐波那契数列<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/367547d1-490e-4577-bcbd-79bbf955bdb1)









