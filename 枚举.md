# 枚举
枚举就是根据提出的问题列出该问题所有的解，然后一个个检验每个可能解是不是真的解。可以解决一些简单的问题，但是运行效率低<br>
能够使用枚举解决的题目一般满足：<br>
* 解枚举的范围是有穷的
* 检验条件是确定的
  <br>
枚举法的结构：枚举范围循环+条件判断语句<br>
一、如图的一个问题<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/57f382fc-05d0-4f87-90b1-2270e722b667)
只需枚举出10到99的所有数字，然后用判断语句找出满足题目条件的数据即可。<br>
```c++
#include<iostream>
using namespace std;
int main(){
  int tot=0;
  for(int i=10;i<=99;i++){
     if(i-(i%10*10+i/10)==27){
        tot++;
     }
   }
  cout<<tot;
  return 0;
 }
```
二、如图：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/c7b693da-abc5-4ef2-9bc0-5eff1762204c)
```c++
#include<iostream>
using namespace std;
int n; //放在全局变量方便judge读取 
int digit[6];
bool judge(int x){
	int i=0,sum=0;
	while(x){  //判断相加的数是否等于n 
		digit[i]=x%10; //将最后一位存入数组 
		i++;
		sum=sum+x%10; //最后一位加进sum 
		x/=10;        //删掉最后一位 
	}
	if(sum!=n){
		return false;
	}
	for(int j=0;j<i/2;j++){//判断是不是回文 
	  if(digit[j]!=digit[i-1-j]){
	  	return false;
	  }
	} 
	return true;
}
int main(){
	cin>>n;
	bool f=false;  //默认不满足
	for(int i=10000;i<100000;i++){//枚举5位数到6位数的所有数字 
		if(judge(i)){
			cout<<i<<endl;
			f=true;
		}
	}
	if(!f){
		cout<<-1<<endl;
	}
	return 0;
}
```
三、如图：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/660aa203-4da7-4122-b132-d917cd97846e)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/f6657e00-56b9-4668-a027-ae1fd92c1cc3)
>题目一共有12个空，可以将12个空的所有条件一一列举出来，当然可以将结果的空去掉，只需枚举8个即可，降低时间复杂度<br>
```c++
#include<iostream>
using namespace std;
int main(){
	
	return 0;
}
```
四、如图<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/5c0013ba-2fee-4346-b192-7c8eac004a45)
>这题可以枚举出在大矩阵范围内的，所有边的长度，然后一一比对找出最大值
```c++
#include<iostream>
using namespace std;
int A[55][55];
int main(){
	int n,m,ans;
	cin>>n>>m;
	ans=-1005;
	for(int i=0;i<n;i++){     //大矩阵的长和宽 
		for(int j=0;j<m;j++){
			cin>>A[i][j];
		}
	}
	for(int i=0;i<n;i++){  //四层for循环是列举大矩阵4条边的所有情况 
		for(int j=i;j<n;j++){
			for(int k=0;k<m;k++){
				for(int l=k;l<m;l++){
					int temp=0;
					for(int p=i;p<=j;p++){     //列举小矩阵在大矩阵里的所有情况 
						for(int q=k;q<=l;q++){
							temp+=A[p][q];
						}
					}
					if(temp>ans){  //有更大的就更新最大值 
						ans=temp;
					}
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}

```






  
