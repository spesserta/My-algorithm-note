# 枚举
## 枚举算法的思想:<br>
>枚举算法的核心思想是将问题的所有可能成为答案的解一一列举，然后根据问题给定的条件判断这些解是否合适。对于符合条件的解，保留:反之则舍弃。<br>
## 枚举算法解题的基本思路:<br>
* 确定枚举解的范围和判断条件: 在开始解题之前，需要明确枚举的解范围，并定义问题的判断条件。<br>
* 选取合适的枚举方法: 选择适当的枚举方式进行逐一枚举，确保覆盖所有可能的解。避免遗漏任何真正的解，同时注意防止重复。<br>
* 使用判断条件检验解: 在枚举过程中，应用事先确定的判断条件验证每个解的合法性，保留符合要求的解。<br>
>枚举算法的一般步骤:<br>
* 确定范围和枚举方式: 根据题目确定枚举的范围，并选择合适的枚举方式。确保不遗漏任何真正的解，同时避免重复。<br>
* 优化解空间: 查看是否存在优化的可能性，以缩小可能成为解的答案范围，提高解决问题的效率。<br>
* 定义准确验证条件: 根据问题找到准确、易编码的验证条件，用于检验每个可能的解。<br>
* 枚举和判断: 逐一枚举解并验证是否符合事先确定的条件，保留符合条件的解。<br>
* 输出结果: 按照要求输出枚举过程中留下的符合条件的解。<br><br>

# 简单枚举<br>
##### 用几层for循环就能解决的问题就是简单问题。<br>
一、如图的一个问题<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/57f382fc-05d0-4f87-90b1-2270e722b667)
只需枚举出10到99的所有数字，然后用判断语句找出满足题目条件的数据即可。<br>
```c++
#include<iostream>
using namespace std;
int main(){
  int tot=0;
  for(int i=10;i<=99;i++){
     if(i-(i%10*10+i/10)==27){
        tot++;
     }
   }
  cout<<tot;
  return 0;
 }
```
二、如图：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/f022d8a2-0237-4998-859f-75f6c5f1d814)
>该题每输入一个数值的时候就可以枚举出它的加减乘除的结果，当枚举到最后一层时，扫描最后一层的所有元素，有等于24的就YES。<br>
```c++
#include<bits/stdc++.h>
using namespace std;
int a[6]; //存入抽出的牌
vector<int> cal[6]; //6个vector数组放运算的结果 
int main(){
	char c;
	cin>>c;     //第一层不用运算，单独拿出来
	if(c=='A'){
        a[0]=1;
	}else if(c=='J'){
 	    a[0]=11;
	}else if(c=='Q'){
		a[0]=12;
	}else if(c=='K'){
		a[0]=13;
	}else{
		a[0]=c-'0'; 
	}
	cal[0].push_back(a[0]);
		
	for(int i=1;i<6;i++){
		cin>>c;
		if(c=='A'){
			a[i]=1;
		}else if(c=='J'){
			a[i]=11;
		}else if(c=='Q'){
			a[i]=12;
		}else if(c=='K'){
			a[i]=13;
		}else{
			a[i]=c-'0'; //相当于c-48 ，将字符转成整数 
		}
		
		for(int j=0;j<cal[i-1].size();j++){
			cal[i].push_back(cal[i-1][j]+a[i]);
			cal[i].push_back(cal[i-1][j]-a[i]);
			cal[i].push_back(cal[i-1][j]*a[i]);
			cal[i].push_back(cal[i-1][j]/a[i]);
		}
	}
	int iS=false;
	for(int i=0;i<6;i++){
		for(int j=0;j<cal[i].size();j++){
			if(cal[i][j]==24){
				cout<<"YES";
				iS=true;
				break;
			}
		}
		if(iS==true) break;
	}
	if(iS==false) cout<<"NO";
	
	return 0;
}
```
三、如图：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/25d06f89-740c-4163-98f0-1a06b89f6c6d)
```c++
#include<iostream>
#include<string>
using namespace std;

bool judge(int i,int j,int k){  //判断这9个数字是否重复
	int num1[3],num2[3],num3[3];
	num1[0]=i/100;
	num1[1]=i/10%10;
	num1[2]=i%10;
	
	num2[0]=j/100;
	num2[1]=j/10%10;
	num2[2]=j%10;
	
	num3[0]=k/100;
	num3[1]=k/10%10;
	num3[2]=k%10;
	
	if((num1[0]!=num1[1])&&(num1[0]!=num1[2])&&num1[0]!=num2[0]&&(num1[0]!=num2[1])&&(num1[0]!=num2[2])&&(num1[0]!=num3[0])&&(num1[0]!=num3[1])&&(num1[0]!=num3[2])
	   &&(num1[1]!=num1[2])&&(num1[1]!=num2[0])&&(num1[1]!=num2[1])&&(num1[1]!=num2[2])&&(num1[1]!=num3[0])&&(num1[1]!=num3[1])&&(num1[1]!=num3[2])
	   &&(num1[2]!=num2[0])&&(num1[2]!=num2[1])&&(num1[2]!=num2[2])&&(num1[2]!=num3[0])&&(num1[2]!=num3[1])&&(num1[2]!=num3[2])
	   &&(num2[0]!=num2[1])&&(num2[0]!=num2[2])&&(num2[0]!=num3[0])&&(num2[0]!=num3[1])&&(num2[0]!=num3[2])
	   &&(num2[1]!=num2[2])&&(num2[1]!=num3[0])&&(num2[1]!=num3[1])&&(num2[1]!=num3[2])
	   &&(num2[2]!=num3[0])&&(num2[2]!=num3[1])&&(num2[2]!=num3[2])
	   &&(num3[0]!=num3[1])&&(num3[0]!=num3[2])
	   &&(num3[1]!=num3[2])) return true;
	else return false;
}

int main()
{
    int A,B,C;
    bool isOK=false;
    cin>>A>>B>>C;
    for(int i=100;i<=999;i++)
     for(int j=i+1;j<=999;j++)
      for(int k=j+1;k<=999;k++){
      	if((i%10==0)||(i/10%10==0)||(j%10==0)||(j/10%10==0)||(k%10==0)||(k/10%10==0))
      	 continue;
      	if((A*j==i*B)&&(B*k==C*j)&&(A*k==C*i)&&(judge(i,j,k))){
      		cout<<i<<" "<<j<<" "<<k<<endl;
      		isOK=true;
      	}
      }
      if(!isOK) cout<<"No!!!";
    return 0;
}
```

四、如图<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/5c0013ba-2fee-4346-b192-7c8eac004a45)
>这题可以枚举出在大矩阵范围内的，所有边的长度，然后一一比对找出最大值
```c++
#include<iostream>
using namespace std;
int A[55][55];
int main(){
	int n,m,ans;
	cin>>n>>m;
	ans=-1005;
	for(int i=0;i<n;i++){     //大矩阵的长和宽 
		for(int j=0;j<m;j++){
			cin>>A[i][j];
		}
	}
	for(int i=0;i<n;i++){  //四层for循环是列举大矩阵4条边的所有情况 
		for(int j=i;j<n;j++){
			for(int k=0;k<m;k++){
				for(int l=k;l<m;l++){
					int temp=0;
					for(int p=i;p<=j;p++){     //列举小矩阵在大矩阵里的所有情况 
						for(int q=k;q<=l;q++){
							temp+=A[p][q];
						}
					}
					if(temp>ans){  //有更大的就更新最大值 
						ans=temp;
					}
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}

```

# 全排列枚举<br>
全排列枚举就是集合内部的所有排列方式，例如1,2,3的全排列就是1,2,3  1,3,2  3,2,1   3,1,2   2,1,3   2,3,1<br>
全排列函数的实现方式：<br>
```c++
int n; //共计N个数
int order[20];
bool chosen[20];
void calc(int k)
{
    if (k == n + 1)
    {
        for (int i = 1; i <= n; i++)
            cout << order[i] << " ";

        puts("");

        return;
    }
    for (int i = 1; i <= n; i++)
    {
        if (chosen[i])
            continue;
        order[k] = i;
        chosen[i] = 1;
        calc(k + 1);
        chosen[i] = 0;
        order[k] = 0;
    }
}
int main()
{
    cin >> n;
    calc(1);
}
```
当然C++可以不应这么麻烦，有现成的库函数可以调用:`next_permutation()`<br>
一、以下面为例：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/dd77b001-885f-4ae8-ab48-990fa44d3e07)

```c++
#include<bits/stdc++.h>
using namespace std;
int num[10];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		num[i-1]=i;
	}
	do{
		for(int j=0;j<n;j++){
                   cout<<setw(5)<<num[j];
		} 
		cout<<endl;
	}while(next_permutation(num,num+n));
	return 0;
}
```
二、例二：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/2f756887-4f46-4907-bb0e-7927b1e105be)
```c++
#include<bits/stdc++.h>
using namespace std;
string stu[11]; 
int main(){
  int N;
  cin>>N;
  for(int i=0;i<N;i++){
    cin>>stu[i];
  }
  do{
    for(int i=0;i<N;i++){
      cout<<stu[i]<<" ";
    }
    cout<<endl;
  }while(next_permutation(stu,stu+N));
  return 0;
}
```

# 组合型枚举<br>
组合型枚举则是在m个元秦中随机选出n个元素的问题。对于每一种可能的选择方案，我们需要确定选择了哪n个元素，这就是组合型枚举。<br>
组合型枚举也有一个固定的模板，是基于深度优先搜索算法实现的：<br>
```c++

#include<bits/stdc++.h>
using namespace std;
int n;//共计N个数
int m;//选m个数
vector<int> chosen;
string s[1000];
void calc(int x) {
    if (chosen.size() > m || chosen.size() + (n - x + 1) < m) //剪枝
        return;
    if (x == n + 1) { //选够了m个数输出
        for (int i = 0; i < chosen.size(); i++)
            cout<< s[chosen[i]]<<" ";//也可以不输出，存放起来也是可以的，主要是看题目。
        puts("");
        return;
    }
    chosen.push_back(x);
    calc(x + 1);
    chosen.pop_back();//消除痕迹
    calc(x + 1);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
    }
    calc(1);
}
```
# 尺取法<br>
>尺取法(双指针法、two pointers)是一种常用的优化技巧，特别适用于解决序列的区间问题。它的操作简单，易于编程，是一种线性高效的算法。<br>
>尺取法的核心思想是维护一个区间(L,)，其中为起点，见为终点，该区间是序列内以工 为起点的最短合法区间。<br>
>关键在于 R 随着  的增大而增大。通过不断枚举 工，同时求解相应的 卫，可以高效地解决问题。<br>
>具体的实现步骤是、不断移动L指针，同时更新R指针、直到R随着L的增大而增大。因为R随着L的增大而增大，所以总的时间复杂度为 O(n)。<br>
>通过维护两个指针，即左指针し和右指针"。通过不断确定区间的左端点，让右指针,不断向右移动，直到满足条件停下，然后维护答案。<br>
>这个过程重复进行直到左指针l超过右指针，或满足其他特定情况(根据题目而定)。尺取法的应用范围广泛，特别适用于需要寻找满足某种条件的连续子序列的问题。<br>
>通过灵活运用尺取法，可以在保持算法简洁的同时，提高解题效率。<br>














