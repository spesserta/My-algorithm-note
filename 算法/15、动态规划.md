# 动态规划-记忆化搜索

### 一、以数楼梯这题为例

![image](https://github.com/spesserta/My-note/assets/138494873/da2804e3-4e65-4696-8f65-a9803af12944)


>到达每层楼时可以向上跳一步，也可以跳2步。这是一个很明显的递归搜索问题
```cpp
#include<bits/stdc++.h>
using namespace std;
int dfs(int x){
	if(x==1) return 1;
	if(x==2) return 2;
	return dfs(x-1)+dfs(x-2);
}
int main(){
	int n; cin>>n;
	int res=dfs(n);
	cout<<res;
	return 0;
}
```
>但是当数据量变大时，它花费的时间也会越来越高。为了解决这个问题，可以利用它每层都会重复调用n次的特性，使用记忆化搜索让每层最多调用一次，这样就可以极大的减少时间花费。
```cpp
#include<bits/stdc++.h>
using namespace std;
int mem[50];
int dfs(int x){
	if(mem[x]) return mem[x]; //之前已经调用过 
	//没被调用过就现场算出来然后存起来 
	int sum=0;
	if(x==1) sum=1;
	else if(x==2) sum=2;
	else sum=dfs(x-1)+dfs(x-2);
	mem[x]=sum;
	return mem[x];
}
int main(){
	int n; cin>>n;
	int res=dfs(n);
	cout<<res;
	return 0;
}
```
>记忆化搜索递归是由上到下推得的结果，‘递’是将大问题分解成重复的小问题，‘归’的过程才是产生答案的过程。递推则是由下到上得到的结果，答案是直接产生的。
```cpp
#include<bits/stdc++.h>
using namespace std;
int f[50];

int main(){
	int n; cin>>n;
	f[1]=1; f[2]=2;
	for(int i=3;i<=n;i++){ //从1推到n 
		f[i]=f[i-1]+f[i-2];
	}
	cout<<f[n];
	return 0;
}
```
>递归-->记忆化搜索-->递推(dp) 这是动态规划最开始的入门
>递归=暴力dfs
>记忆化搜索=暴力dfs+记录答案
>递推公式=dfs向下递归的公式，递推数组的初始值=递归的边界

### 二、数字三角形

![image-1](https://github.com/spesserta/My-note/assets/138494873/80f429c2-ac8a-4be2-8624-bac0b275e2a2)

>首先这题可以用DFS搜索一下，每一层都返回这层和下一层之和的最大值，这是一个最优子问题（区分于子问题之和），可以直接return max(dfs(x+1,y)+当前数字,dfs(x+1,y+1)+当前数字); 
```cpp
#include<bits/stdc++.h>
using namespace std;
int mp[1010][1010],n;
int dfs(int x,int y){
	if(x>n||y>x) return 0;
    //每层都返回这层和下一层之和的最大值
	else return max(dfs(x+1,y)+mp[x][y],dfs(x+1,y+1)+mp[x][y]);
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin>>mp[i][j];
		}
	}
	int res=dfs(1,1); //从第1层到第n层
	cout<<res;
	return 0;
}
```
>结果应该是TLE了，通过样例可以看出有些点遍历过2次或者多次，可以试试记忆化搜索
```cpp
#include<bits/stdc++.h>
using namespace std;
int mp[1010][1010],n;
int mem[1010][1010];
int dfs(int x,int y){
	if(mem[x][y]) return mem[x][y];
	else{
		if(x>n||y>x) mem[x][y]=0;
		else mem[x][y]=max(dfs(x+1,y)+mp[x][y],dfs(x+1,y+1)+mp[x][y]);
		return mem[x][y];
		
	}
}
int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin>>mp[i][j];
		}
	}
	int res=dfs(1,1);
	cout<<res;
	return 0;
}
```
>结果还是超时了哈哈，因为重合点的部分调用次数不是很多，记忆化的效果不大，还得需要优化一下，用递推吧，递归是从上往下，递推则是从底部开始向上推。
```cpp
#include<bits/stdc++.h>
using namespace std;
int mp[1010][1010],n;
int f[1010][1010];

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=1;j<=n;j++){
			f[i][j]=max(f[i+1][j]+mp[i][j],f[i+1][j+1]+mp[i][j]);
		}
	}
	cout<<f[1][1];
	return 0;
}
```
>现在时间复杂度直接干到了O(n)，除了向上反着推，也可以向下正着推，但是到了最下面是多个数字，需要再次遍历找出最终的最大值。
```cpp
#include<bits/stdc++.h>
using namespace std;
int mp[1010][1010],n;
int f[1010][1010];

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=i;j++){
			cin>>mp[i][j];
		}
	}
	for(int i=1;i<=n;i++){ //正推
		for(int j=1;j<=i;j++){
			f[i][j]=max(f[i-1][j]+mp[i][j],f[i-1][j-1]+mp[i][j]);
		}
	}
	int res=0;
	for(int i=1;i<=n;i++){ //寻找最大值
		res=max(f[n][i],res);
	}
	cout<<res;
	return 0;
}
```
