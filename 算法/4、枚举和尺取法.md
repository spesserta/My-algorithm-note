# 枚举
## 枚举算法的思想:<br>
>枚举算法的核心思想是将问题的所有可能成为答案的解一一列举，然后根据问题给定的条件判断这些解是否合适。对于符合条件的解，保留:反之则舍弃。<br>
## 枚举算法解题的基本思路:<br>
* 确定枚举解的范围和判断条件: 在开始解题之前，需要明确枚举的解范围，并定义问题的判断条件。<br>
* 选取合适的枚举方法: 选择适当的枚举方式进行逐一枚举，确保覆盖所有可能的解。避免遗漏任何真正的解，同时注意防止重复。<br>
* 使用判断条件检验解: 在枚举过程中，应用事先确定的判断条件验证每个解的合法性，保留符合要求的解。<br>
>枚举算法的一般步骤:<br>
* 确定范围和枚举方式: 根据题目确定枚举的范围，并选择合适的枚举方式。确保不遗漏任何真正的解，同时避免重复。<br>
* 优化解空间: 查看是否存在优化的可能性，以缩小可能成为解的答案范围，提高解决问题的效率。<br>
* 定义准确验证条件: 根据问题找到准确、易编码的验证条件，用于检验每个可能的解。<br>
* 枚举和判断: 逐一枚举解并验证是否符合事先确定的条件，保留符合条件的解。<br>
* 输出结果: 按照要求输出枚举过程中留下的符合条件的解。<br><br>

# 简单枚举<br>
##### 用几层for循环就能解决的问题就是简单问题。<br>
一、如图的一个问题<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/57f382fc-05d0-4f87-90b1-2270e722b667)
只需枚举出10到99的所有数字，然后用判断语句找出满足题目条件的数据即可。<br>
```c++
#include<iostream>
using namespace std;
int main(){
  int tot=0;
  for(int i=10;i<=99;i++){
     if(i-(i%10*10+i/10)==27){
        tot++;
     }
   }
  cout<<tot;
  return 0;
 }
```
二、24点问题：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/f022d8a2-0237-4998-859f-75f6c5f1d814)
>该题每输入一个数值的时候就可以枚举出它的加减乘除的结果，当枚举到最后一层时，扫描最后一层的所有元素，有等于24的就YES。<br>
```c++
#include<bits/stdc++.h>
using namespace std;
int a[6]; //存入抽出的牌
vector<int> cal[6]; //6个vector数组放运算的结果 
int main(){
	char c;
	cin>>c;     //第一层不用运算，单独拿出来
	if(c=='A'){
        a[0]=1;
	}else if(c=='J'){
 	    a[0]=11;
	}else if(c=='Q'){
		a[0]=12;
	}else if(c=='K'){
		a[0]=13;
	}else{
		a[0]=c-'0'; 
	}
	cal[0].push_back(a[0]);
		
	for(int i=1;i<6;i++){
		cin>>c;
		if(c=='A'){
			a[i]=1;
		}else if(c=='J'){
			a[i]=11;
		}else if(c=='Q'){
			a[i]=12;
		}else if(c=='K'){
			a[i]=13;
		}else{
			a[i]=c-'0'; //相当于c-48 ，将字符转成整数 
		}
		
		for(int j=0;j<cal[i-1].size();j++){
			cal[i].push_back(cal[i-1][j]+a[i]);
			cal[i].push_back(cal[i-1][j]-a[i]);
			cal[i].push_back(cal[i-1][j]*a[i]);
			cal[i].push_back(cal[i-1][j]/a[i]);
		}
	}
	int iS=false;
	for(int i=0;i<6;i++){
		for(int j=0;j<cal[i].size();j++){
			if(cal[i][j]==24){
				cout<<"YES";
				iS=true;
				break;
			}
		}
		if(iS==true) break;
	}
	if(iS==false) cout<<"NO";
	
	return 0;
}
```
三、如图：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/25d06f89-740c-4163-98f0-1a06b89f6c6d)
```c++
#include<iostream>
#include<string>
using namespace std;

bool judge(int i,int j,int k){  //判断这9个数字是否重复
	int num1[3],num2[3],num3[3];
	num1[0]=i/100;
	num1[1]=i/10%10;
	num1[2]=i%10;
	
	num2[0]=j/100;
	num2[1]=j/10%10;
	num2[2]=j%10;
	
	num3[0]=k/100;
	num3[1]=k/10%10;
	num3[2]=k%10;
	
	if((num1[0]!=num1[1])&&(num1[0]!=num1[2])&&num1[0]!=num2[0]&&(num1[0]!=num2[1])&&(num1[0]!=num2[2])&&(num1[0]!=num3[0])&&(num1[0]!=num3[1])&&(num1[0]!=num3[2])
	   &&(num1[1]!=num1[2])&&(num1[1]!=num2[0])&&(num1[1]!=num2[1])&&(num1[1]!=num2[2])&&(num1[1]!=num3[0])&&(num1[1]!=num3[1])&&(num1[1]!=num3[2])
	   &&(num1[2]!=num2[0])&&(num1[2]!=num2[1])&&(num1[2]!=num2[2])&&(num1[2]!=num3[0])&&(num1[2]!=num3[1])&&(num1[2]!=num3[2])
	   &&(num2[0]!=num2[1])&&(num2[0]!=num2[2])&&(num2[0]!=num3[0])&&(num2[0]!=num3[1])&&(num2[0]!=num3[2])
	   &&(num2[1]!=num2[2])&&(num2[1]!=num3[0])&&(num2[1]!=num3[1])&&(num2[1]!=num3[2])
	   &&(num2[2]!=num3[0])&&(num2[2]!=num3[1])&&(num2[2]!=num3[2])
	   &&(num3[0]!=num3[1])&&(num3[0]!=num3[2])
	   &&(num3[1]!=num3[2])) return true;
	else return false;
}

int main()
{
    int A,B,C;
    bool isOK=false;
    cin>>A>>B>>C;
    for(int i=100;i<=999;i++)
     for(int j=i+1;j<=999;j++)
      for(int k=j+1;k<=999;k++){
      	if((i%10==0)||(i/10%10==0)||(j%10==0)||(j/10%10==0)||(k%10==0)||(k/10%10==0))
      	 continue;
      	if((A*j==i*B)&&(B*k==C*j)&&(A*k==C*i)&&(judge(i,j,k))){
      		cout<<i<<" "<<j<<" "<<k<<endl;
      		isOK=true;
      	}
      }
      if(!isOK) cout<<"No!!!";
    return 0;
}
```

四、最大子矩阵<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/5c0013ba-2fee-4346-b192-7c8eac004a45)
>这题可以枚举出在大矩阵范围内的，所有边的长度，然后一一比对找出最大值
```c++
#include<iostream>
using namespace std;
int A[55][55];
int main(){
	int n,m,ans;
	cin>>n>>m;
	ans=-1005;
	for(int i=0;i<n;i++){     //大矩阵的长和宽 
		for(int j=0;j<m;j++){
			cin>>A[i][j];
		}
	}
	for(int i=0;i<n;i++){  //列举出小矩阵的4条边的所有情况
		for(int j=i;j<n;j++){
			for(int k=0;k<m;k++){
				for(int l=k;l<m;l++){
					int temp=0;
					for(int p=i;p<=j;p++){     //计算出小矩阵内的元素之和
						for(int q=k;q<=l;q++){
							temp+=A[p][q];
						}
					}
					if(temp>ans){  //有更大的就更新最大值 
						ans=temp;
					}
				}
			}
		}
	}
	cout<<ans<<endl;
	return 0;
}

```

# 全排列枚举<br>
全排列枚举就是集合内部的所有排列方式，例如1,2,3的全排列就是1,2,3  1,3,2  3,2,1   3,1,2   2,1,3   2,3,1<br>
全排列函数的实现是基于递归+回溯算法实现的，实现如下：<br>
```c++
int n; //共计N个数
int order[20];
bool chosen[20];
void calc(int k)
{
    if (k == n + 1)
    {
        for (int i = 1; i <= n; i++)
            cout << order[i] << " ";

        puts("");

        return;
    }
    for (int i = 1; i <= n; i++)
    {
        if (chosen[i])
            continue;
        order[k] = i;
        chosen[i] = 1;
        calc(k + 1);
        chosen[i] = 0;
        order[k] = 0;
    }
}
int main()
{
    cin >> n;
    calc(1);
}
```
当然C++可以不应这么麻烦，有现成的库函数可以调用:`next_permutation()`<br>
一、全排列：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/dd77b001-885f-4ae8-ab48-990fa44d3e07)

```c++
#include<bits/stdc++.h>
using namespace std;
int num[10];
int main(){
	int n;
	cin>>n;
	for(int i=1;i<=n;i++){
		num[i-1]=i;
	}
	do{
		for(int j=0;j<n;j++){
                   cout<<setw(5)<<num[j];
		} 
		cout<<endl;
	}while(next_permutation(num,num+n));
	return 0;
}
```
二、座次问题：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/2f756887-4f46-4907-bb0e-7927b1e105be)
```c++
#include<bits/stdc++.h>
using namespace std;
string stu[11]; 
int main(){
  int N;
  cin>>N;
  for(int i=0;i<N;i++){
    cin>>stu[i];
  }
  do{
    for(int i=0;i<N;i++){
      cout<<stu[i]<<" ";
    }
    cout<<endl;
  }while(next_permutation(stu,stu+N));
  return 0;
}
```

# 组合型枚举<br>
组合型枚举则是在m个元秦中随机选出n个元素的问题。对于每一种可能的选择方案，我们需要确定选择了哪n个元素，这就是组合型枚举。<br>
组合型枚举也有一个固定的模板，是基于深度优先搜索算法实现的：<br>
```c++

#include<bits/stdc++.h>
using namespace std;
int n;//共计N个数
int m;//选m个数
vector<int> chosen;
string s[1000];
void calc(int x) {
    if (chosen.size() > m || chosen.size() + (n - x + 1) < m) //剪枝
        return;
    if (x == n + 1) { //选够了m个数输出
        for (int i = 0; i < chosen.size(); i++)
            cout<< s[chosen[i]]<<" ";//也可以不输出，存放起来也是可以的，主要是看题目。
        puts("");
        return;
    }
    chosen.push_back(x);
    calc(x + 1);
    chosen.pop_back();//消除痕迹
    calc(x + 1);
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++)
    {
        cin>>s[i];
    }
    calc(1);
}
```
# 尺取法<br>
>尺取法(双指针法、two pointers)是一种常用的优化技巧，特别适用于解决序列的区间问题。它的操作简单，易于编程，是一种线性高效的算法。<br>
>尺取法的核心思想是维护一个区间(L,)，其中为起点，见为终点，该区间是序列内以工 为起点的最短合法区间。<br>
>关键在于R随着L的增大而增大。通过不断枚举L，同时求解相应的R，可以高效地解决问题。<br>
>具体的实现步骤是、不断移动L指针，同时更新R指针、直到R随着L的增大而增大。因为R随着L的增大而增大，所以总的时间复杂度为 O(n)。<br>
>通过维护两个指针，即左指针l和右指针r。通过不断确定区间的左端点，让右指针r不断向右移动，直到满足条件停下，然后维护答案。<br>
>这个过程重复进行,直到左指针l超过右指针r，或满足其他特定情况(根据题目而定)。尺取法的应用范围广泛，特别适用于需要寻找满足某种条件的连续子序列的问题。<br>
>通过灵活运用尺取法，可以在保持算法简洁的同时，提高解题效率。<br>
一、奇怪的动物园<br>
![image](https://github.com/spesserta/My-note/assets/138494873/f5d76227-9a62-455d-8725-116816f39518)
![image](https://github.com/spesserta/My-note/assets/138494873/54902a23-82b5-48e8-840c-5b60a6175afc)
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1000005;

int n, m, a[MAXN], b[MAXN], cnt, ans, ansl, ansr;

// 加入第x种动物
inline void I(int x) {
    if (b[x] == 0) cnt++; // 如果该动物没有在当前区间中出现过，增加唯一动物数量
    b[x]++; // 动物x的数量加1
}

// 删除第x种动物
inline void D(int x) {
    if (b[x] == 1) cnt--; // 如果删除后该动物不再在当前区间中出现，减少唯一动物数量
    b[x]--; // 动物x的数量减1
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]); // 读取每种动物的种类

    ans = n;
    for (int r = 1, l = 1; r <= n; r++) {
        I(a[r]); // 首先插入a[r]的动物

        while (true) {
            D(a[l]); // 先删a[l]的动物
            if (cnt == m) l++; // 如果删了没事，加l
            else {
                I(a[l]);
                break; // 删了有事，还留着
            }
        }

        if (cnt == m && r - l + 1 < ans) {
            ans = r - l + 1;
            ansl = l;
            ansr = r;
        }
    }

    if (ansl != 0) printf("%d %d", ansl, ansr);
    else printf("1 %d", n); // 输出+特判：选择任意一个≤n的区间不满足要求，则只好选择区间[1,n]

    return 0;
}
```



# 暴力打表<br>
一、回文质数：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/6015e3f2-ba70-4059-a650-8c3675834d49)
>如果该题用暴力方法一个个判断的话大概率就是超时了。<br>
```c++
#include<iostream>
using namespace std;
int num[10];
bool juege(int x){ //判断回文 
	int i=0;
	while(x){
		num[i]=x%10;
		x/=10;
		i++;
	}
	for(int j=0;j<i/2;j++){  
		if(num[j]!=num[i-j-1]){
			return false;
		}
	}
	return true;
}
bool judge(int x){  //判断质数 
	if(x==1||x==0){
		return false;
	}
	if(x%2==0){
		return false;
	}
	for(int i=2;i<x/3+1;i++){
		if(x%i==0){
			return false;
		}
	}
	return true;
}
int main(){
	int a,b;
	cin>>a>>b;
	for(int i=a;i<=b;i++){
	    if(i%2==0){
	        continue;
	    }
		if(i<10){
			cout<<i<<endl;
		}else if(juege(i)&&judge(i)){
			cout<<i<<endl;
		}
	}
	
	return 0;
}
```
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/b79de558-61e4-48f0-b208-985119b6e6e0)
<br>
因此这种情况下，有一种更高效的算法可以用，可以先另外写一个程序，输出1到1亿所有的回文质数，然后存入该题的一个数组中，当输入一个区间范围是，输出该范围内的所有值即可。<br>
>输出所有的回文质数：
```c++
#include<iostream>
using namespace std;
int num[10];
bool juege(int x){ //判断回文 
	int i=0;
	while(x){
		num[i]=x%10;
		x/=10;
		i++;
	}
	for(int j=0;j<i/2;j++){  
		if(num[j]!=num[i-j-1]){
			return false;
		}
	}
	return true;
}
bool judge(int x){  //判断质数 
	if(x==1||x==0){
		return false;
	}
	if(x%2==0){
		return false;
	}
	for(int i=2;i<x/3+1;i++){
		if(x%i==0){
			return false;
		}
	}
	return true;
}
int main(){
	int count=0; 
	for(int i=3;i<=100000000;i++){
	    if(i%2==0){
	        continue;
	    }
		if(i<10){
			cout<<i<<endl; 
			count++;
		}else if(juege(i)&&judge(i)){
			cout<<i<<endl;
			count++;
		}
	}
	cout<<count;
	
	return 0;
}
```
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/91fb5afc-98dc-4c7c-a91e-3b379ab0ee0e)

这样我们就得到了781个数字，将其存入题目的一个数组之中，再加上一个简单的判断，答案就出来了。<br>
```c++
#include<iostream>
using namespace std;
int num[800]={0,2,3,5,7,11,101,131,151,181,
191,313,353,373,383,727,757,787,797,
919,929,10301,10501,10601,11311,11411,12421,12721,
12821,13331,13831,13931,14341,14741,15451,15551,16061,
16361,16561,16661,17471,17971,18181,18481,19391,19891,
19991,30103,30203,30403,30703,30803,31013,31513,32323,
32423,33533,34543,34843,35053,35153,35353,35753,36263,
36563,37273,37573,38083,38183,38783,39293,70207,70507,
70607,71317,71917,72227,72727,73037,73237,73637,74047,
74747,75557,76367,76667,77377,77477,77977,78487,78787,
78887,79397,79697,79997,90709,91019,93139,93239,93739,
94049,94349,94649,94849,94949,95959,96269,96469,96769,
97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,
1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,
1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,
1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,
1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,
1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,
1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,
1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,
1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,
1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,
1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,
1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,
1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,
1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,
1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,
1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,
1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,
1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,
1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,
1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,
1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,
1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,
3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,
3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,
3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,
3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,
3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,
3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,
3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,
3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,
3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,
3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,
3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,
3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,
3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,
3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,
3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,
3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,
3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,
3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,
3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,
7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,
7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,
7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,
7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,
7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,
7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,
7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,
7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,
7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,
7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,
7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,
7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,
7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,
7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,
7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,
7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,
7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,
9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,
9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,
9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,
9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,
9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,
9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,
9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,
9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,
9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,
9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,
9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,
9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,
9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,
9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,
9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,
9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,
9938399,9957599,9965699,9978799,9980899,9981899,9989899,
781};
int main(){
	int n,m;
	cin>>n>>m;
	for(int i=1;i<=781;i++){
		if(n<=num[i]&&m>=num[i]){
			cout<<num[i]<<endl;
		}
	}
	return 0;
}

```








