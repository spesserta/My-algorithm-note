
## 普通查找和二分查找
相比于普通查找的O(n)复杂度，二分查找的复杂度更小，为O(log2n)，时间复杂度更低。<br>
## 二分查找思想
该方法将个元素分成大致相等的两部分，选取中间元素与查找的元素进行比较。<br>
* 如果相等，则查找成功;
* 如果查找元素小于中间元素，则在左半区继续查找
* 如果查找元素大于中间元素，则在右半区继续查找。<br>
每次都将范围缩小至原来的一半，因此时间复杂度是o(1og2n)。<br>
需要注意的是，二分查找的前提是数组有序，一般是从小到大排列。<br>
<br>

在有序表中(1ow，high，low<=high)，取中间记录即 a[(high+low)/2]作为比较对象。<br>
* 若给定值与中间记录的关键码相等，则查找成功。
* 若给定值小于中间记录的关键码，则在中间记录的左半区继续查找。
* 若给定值大于中间记录的关键码，则在中间记录的右半区继续查找。
不断重复上述过程，直到查找成功或所查找的区域无记录，查找失败。<br><br>

![image](https://github.com/spesserta/My-note/assets/138494873/5532113c-a362-4711-b6c3-72e771549533)


## 判断是否可以使用二分法
关键词：递增or递减序列，查找大于某数的最小值和小于某数的最大值

# 整数二分算法

## 整数二分算法的最佳模板
>如果能找到该值，就返回该值，否则就返回该值的前驱或者后继，包含了需要二分查找的多种情况。
```cpp
// 在单调递增序列a中查找>=x的数中最小的一个（即x或x的后继）
while (low < high)
{
    int mid = (low + high) / 2;
    if (a[mid] >= x)
        high = mid;

    else
        low = mid + 1;
}
cout<<a[low];

// 在单调递增序列a中查找<=x的数中最大的一个（即x或x的前驱）
while (low < high)
{
    int mid = (low + high + 1) / 2;

    if (a[mid] <= x)
        low = mid;

    else
        high = mid - 1;
}
cout<<a[low];
```
## 一、跳石头

![image-1](https://github.com/spesserta/My-note/assets/138494873/2cdfe55b-8553-4543-9de8-d6d3b0d24f0b)


>该题可以用暴力解法，即列举所有搬走石头的情况，这样容易超时<br>

>给定一个d，如果能在搬走m个石头的情况下达到这个d，就满足。把所有的d都尝试一遍，用二分法来找到这个d。<br>

二分可以套模板实现，主要解决的是判断的问题，检查d是否合适。<br>

>可以从第一个石头开始为站立点，尝试后边所有的石头，判断可不可以移走石头，如果不能移走石头，跳过已经移走了的石头来更新站立点

```cpp
bool check(){
   int num=0;   //记录搬走石头的数量
   int pos=0;   //当前站立的石头
   for(int i=0;i<=n;i++){  
     if(stone[i]-pos<d) num++;   //第i块石头可以搬走
     else pos=stone[i];          //不能搬走就更新站立的石头
     if(num<=m)  return true;    //需要移动的是否小于m就可以
     else return false;
   }

}
```
完整过程：
```cpp
int left=0,right=len,mid,ans=0;
while(left<right){
  mid=(left+right+1)/2;
  if(check(mid)){
   left=mid;
  }else{
    right=mid-1;
   }
}
cout<<left;
```
## 二、分巧克力
![image-3](https://github.com/spesserta/My-note/assets/138494873/340f5f3f-e552-4c27-abb9-bf653bb8d6c5)

![image-4](https://github.com/spesserta/My-note/assets/138494873/0f1c8040-ab0a-48df-a693-0cf143df0c30)
![image-5](https://github.com/spesserta/My-note/assets/138494873/4441eaac-bef1-4ac9-a88a-eda16318a0a5)
>关键词：尽可能大的最大边长，可以看出用二分来做合适，我们可以对分巧克力的边长进行二分，找出满足条件下最大的边长。
>简单思路，边长的最大规模为 100000;我们可以枚举出所有的情况。按从大到小的顺序进行切割，直到找到满足要求的巧克力边长。
>由于暴力枚举容易超时，用二分来查找即可
```cpp
#include<iostream>
using namespace std;
int N,K;
struct Cho{
    int w;  //巧克力的长
    int h;  //巧克力的宽
}ch[100010];
bool pd(int x){   //判断边长为x的情况下能不能切出k个正方形巧克力
	int sum=0;
	for(int i=0;i<N;i++){
		sum+=(ch[i].h/x)*(ch[i].w/x);
		if(sum>=K){
			return true;
		}
	}
	return false;
}
int main(){
	cin>>N>>K;
	for(int i=0;i<N;i++){
		cin>>ch[i].h>>ch[i].w;
	}
	int high=0;
	for(int i=0;i<N;i++){    //找到二分的上界 
		high=max(high,ch[i].h);
		high=max(high,ch[i].w); 
	}
	int low=1;              //二分的下界为1
	int mid;
	while(low<high){
		mid=(low+high+1)/2;
		if(pd(mid)){
			low=mid;
		}else{
			high=mid-1;
		}
	} 
	cout<<low;
	return 0;
}
```

# 实数二分算法

相比于整数二分，实数二分更为简单，因为不用考虑整数向下取整的问题，不需要进行边界判断。

## 实数二分模板

```cpp
//模版一：实数域二分，设置eps法

//令 eps 为小于题目精度一个数即可。比如题目说保留4位小数，0.0001 这种的。那么 eps 就可以设置为五位小数的任意一个数 0.00001- 0.00009 等等都可以。

//一般为了保证精度我们选取精度/100 的那个小数，即设置 eps= 0.0001/100 =1e-6

while (l + eps < r)
{
    double mid = (l + r) / 2;

    if (pd(mid))
        r = mid;
    else
        l = mid;
}

//模版二：实数域二分，规定循环次数法
//通过循环一定次数达到精度要求，这个一般 log2N < 精度即可。N 为循环次数，在不超过时间复杂度的情况下，可以选择给 N 乘一个系数使得精度更高。

    for (int i = 0; i < 100; i++)
{

    double mid = (l + r) / 2;
    if (pd(mid))
        r = mid;
    else
        l = mid;
}
```

## 一、M次方根

![image-2](https://github.com/spesserta/My-note/assets/138494873/18b6fd97-e814-4a78-97bb-0666ffa191fd)


```cpp
#include<iostream>
#include<cmath>
using namespace std;
double N,M;
double eps=0.000000001; 
bool judge(double x){
    if(pow(x,M)>=N){   //x的M次方大于N
		return true;
	}else{
		return false;
	}
}
int main(){
	double left,right,mid;
	cin>>N>>M;
    left=0; right=N;      
	while(right-left>eps){   
		double mid=(left+right)/2;
		if(judge(mid)){  //mid大了
			right=mid;   //缩短右边的区间
		}else{ 
			left=mid;    //缩短左边的区间

		}
	} 
	printf("%.7f",left);
	return 0;
}
```

