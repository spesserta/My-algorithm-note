# 广度优点搜索<br>
广度优先搜索（BFS）相比于深度优先搜索（DFS），是一层一层展开的，当有多个终态时，最先找到的一定是最短的。DFS和BFS算法在一般情况下可以相互转化。<br>
伪代码思路：<br>
```
int check(参数)
{
    if(满足条件)
        return 1;
    return 0;
}
bool pd(参数){
    相应操作
}
void bfs()
{
    1. 把根节点放入队列尾端
    2. 每次从队列中取出一个节点
    3. Check 判断是不是答案，如果是结束算法 return;
    4. 把当前取出的节点扩展，如果扩展后的节点经Pd()后符合要求，就放入队列，不符合就不放。
    5. 转到步骤2，循环执行
}

如果所有节点被扩展完了，没有找到答案就无解。
```
一、题型1：
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/7ae6b7c6-6513-4055-bbe2-9422c9af0ef2)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/db1fbe82-5968-4660-921f-f812e40dd200)
```c++
#include<iostream>
#include<queue>
using namespace std;
int n,m,day;
char mp[1005][1005];
struct Axi{
	int x,y,d;
}ax;
queue<Axi> qu;
int dirx[4]={0,1,0,-1};
int diry[4]={1,0,-1,0};

bool judge(int x,int y){
	if(x<1||x>n||y<1||y>m){ //超出边界了 
		return false;
	}else if(mp[x][y]=='g'){ //已经长过草了 
		return false;
	}
	return true; 
}

void BFS(){
	for(int i=1;i<=n;i++){  //扫描第0天的草，存入队列 
		for(int j=1;j<=m;j++){
			if(mp[i][j]=='g'){
				ax.x=i;
				ax.y=j;
				ax.d=0;
				qu.push(ax);
			}
		}
	}
	
	for(int i=1;i<=day;i++){  //开始长草 
	    int len=qu.size(); //获取当前队列的长度
	  	while(len){
	  		for(int j=0;j<4;j++){ //列举4个方向 
		 	   int tx=qu.front().x+dirx[j];
		     int ty=qu.front().y+diry[j];
		     if(judge(tx,ty)){
     		   ax.x=tx;
     		   ax.y=ty;
     		   ax.d=i;
     		   qu.push(ax);
     		   mp[tx][ty]='g'; 
		    }
		 }
		 qu.pop();
		 len--;
	  	}	 
	  }
	  	
	      
	}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
		}
	}
	cin>>day;
	
	BFS();
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<mp[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```
