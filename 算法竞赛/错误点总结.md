# 零碎知识点总结
## 1、闰年分为普通闰年和世纪闰年，普通闰年能被4整除且不能被100整除，世纪闰年能被100和400同时整除。<br>
 普通闰年判断：<br>
```c++
if(a%4==0&&a%100!=0)
```
 世纪闰年判断：<br>
```c++
if(a%100==0&&a%400==0)
```
## 2、取整问题：<br>
 >取整问题可以分成三类：向上取整、向下取整、四舍五入，可以通过自己编写代码或者调用函数得到<br>
 不调用任何函数的取整方法：<br>
 ```c++
(int)(a+1) //单一变量取整
if(a%b==0) result=a/b; //表达式的结果取整
else result=a/b+1
```
调用取整函数：<br>
```c++
//向下取整用强制转换即可
(int)(9.77)为9
//向上取整用std::ceil(浮点数)
std::ceil(8.688)为9
//四舍五入取整用round(浮点数)
round(3.4)为3
rounf(3.5)为4
```
## 3、在C++中除了或(||)、且(&&)、非(!)这三个逻辑运算符，还有异或(^)运算符，当只有满足一个为真一个为假的条件时才能为真。
```c++
bool a=true,b=true,c=false,d=false;
//a^b为false
//a^c为true
//c^d为false
```
## 4、数字的倒序
```c++
int rev(int x){
	int ret=0;  //翻转后的数字 
	while(x){
		ret=ret*10+x%10; //每次循环ret乘10，然后再加上x的余数 
		x/=10;   //x取完余数后再往前进一位 
	}
	return ret;
}
int
```
## 5、找出最大公因数和最小公倍数算法<br>
### 5.1、求最大公因数有更相减损法和辗转相除法两种：<br>
#### 5.1.1、更相减损法： <br>
  假设我们要求378和90两个数的最大公因数，将大的数字减去小的数字即378-90=288，在将结果和较小的数字相比较，再将大的数字减去小的数字，如此循环直到两数相等为止。<br>
  完整过程： 378-90=288 288-90=198 198-90=108 108-90=18 90-18=72 72-18=54 54-18=36 36-18=18 停止<br>
此时，相等的两个数18即为最大公因数。<br><br>
*算法实现：*
```c++
int Getmin(int x,int y) 
{
	int temp=0;
	while(x!=y)
	{
     if(x>y)
	   {
	      temp=x-y;
	      swap(x,temp);
	   }
	   else
	   {
	      temp=y-x; 
	      swap(y,temp);
      }
	}
	return y;
}
```

#### 5.1.2、辗转相除法：<br>
改方法逻辑上和更相减损法相似，将大的数值除以小的数值得出一个余数，再用除数继续除以余数得出新余数，如此反复到余数为0停止，此时的除数就是最大公约数。<bt>
*算法实现：*<br>
```c++
int Getmin(int x,int y)
{
    int temp=x%y;    
    while(temp!=0)
{
 
        x=y; 
        y=temp;
        temp=x%y;
    }
    return y;  //返回y值
}
```
*短一点的递归算法*
```
int Getmin(int a,int b)
{
return b==0 ? a: Getmin(b,a%b);
}
```
### 5.2、求最小公倍数：<br>
#### 5.2.1、不断从小到大枚举直到满足x%a==0 && x%b==0<br>
由于这样做时间复杂度高，需要进行一些优化。首先最小公倍数满足两个数的相同倍数，由此可知最小公倍数是大于两个数的，这样就不需要从1开始不断枚举了;其次最小公倍数可以从其中一个倍数开始不断列举它的所有倍数，直到满足为另一个数的倍数这一条件即可。再优化一点就是从2个数中找出更大的，列举它的所有公倍数。<br>
*算法实现：*<br><br>
```c++
int Getmax(int a,int b)
{
	int max=a>b?a:b;
	int n=max;
	while(1)
	{
		if(n%a==0&&n%b==0)
		 break;
	    n+=max;
	}
	return n;
}
```
## 6、如果算法题需要往数组里面输入数字，但是输入的长度未知，可以尝试以下方法：<br>
首先把数组开到够大，然后:<br>
```c++
int num[100000];
int i=0,count=0;
while(cin>>num[i++]){  //重点
     count++;
	}
```
这样的话当输入到达末尾EOF时自动停止输入，在编译器里面可能无法调试，直接Ctr+z手动停止输入即可。<br>


## 7、将char直接转成一个int型数字不能直接强转或者减0转换
例如'0'强转的int值为48，这是字符'0'的ASCII码，如果要准确的转成int型，直接减去48即可。
```c++
char c1='0';
int a=c1-48;
cout<<a;  //结果为数字0
int b=c1-'0'; //这样写也可
```
## 8、计算成绩之差的时候一定要考虑正负的问题！！<br>
以洛谷P5741为例：<br>
原代码：
```c++
#include<bits/stdc++.h>
using namespace std;
struct Student{
	string name;
	int score_1,score_2,score_3;
	int sum;
}stu[1005];
bool cmp(Student x,Student y){
	return x.name<y.name;
}
int main(){
	
	int N;
	cin>>N;
	for(int i=0;i<N;i++){
		cin>>stu[i].name>>stu[i].score_1>>stu[i].score_2>>stu[i].score_3;
	}
	for(int i=0;i<N;i++){
		stu[i].sum=stu[i].score_1+stu[i].score_2+stu[i].score_3;
	}
	sort(stu,stu+N,cmp);
	for(int i=0;i<N;i++){
		for(int j=i;j<N;j++){
			if(i==j) continue;
			if((stu[i].sum-stu[j].sum<=10)&&(stu[i].score_1-stu[j].score_1<=5)&&(stu[i].score_2-stu[j].score_2<=5)&&(stu[i].score_3-stu[j].score_3<=5)){
				cout<<stu[i].name<<" "<<stu[j].name<<endl;
			}
		}
	}
	return 0;
}
```
>错误原因是判断分数差小于几的时候没有想到分数相减为负数的情况。<br>
改正后：<br>
```c++
#include<bits/stdc++.h>  
using namespace std;  
  
struct Student {  
    string name;  
    int score_1, score_2, score_3;  
    int sum;  
} stu[1005];  
  
bool cmp(Student x, Student y) {  
    return x.name < y.name;  
}  
  
int main() {  
    int N;  
    cin >> N;  
    for (int i = 0; i < N; i++) {  
        cin >> stu[i].name >> stu[i].score_1 >> stu[i].score_2 >> stu[i].score_3;  
        stu[i].sum = stu[i].score_1 + stu[i].score_2 + stu[i].score_3;  
    }  
    sort(stu, stu + N, cmp);  
    for (int i = 0; i < N; i++) {  
        for (int j = i + 1; j < N; j++) { // 从i+1开始遍历  
            if (abs(stu[i].sum - stu[j].sum) <= 10 && // 使用abs取绝对值  
                abs(stu[i].score_1 - stu[j].score_1) <= 5 &&  
                abs(stu[i].score_2 - stu[j].score_2) <= 5 &&  
                abs(stu[i].score_3 - stu[j].score_3) <= 5) {  
                cout << stu[i].name << " " << stu[j].name << endl;  
            }  
        }  
    }  
    return 0;  
}
```

