# 广度优先搜索<br>
广度优先搜索（BFS）相比于深度优先搜索（DFS），是一层一层展开的，当有多个终态时，最先找到的一定是最短的。DFS和BFS算法在一般情况下可以相互转化。<br>
伪代码思路：<br>
```
int check(参数)
{
    if(满足条件)
        return 1;
    return 0;
}
bool pd(参数){
    相应操作
}
void bfs()
{
    1. 把根节点放入队列尾端
    2. 每次从队列中取出一个节点
    3. Check 判断是不是答案，如果是结束算法 return;
    4. 把当前取出的节点扩展，如果扩展后的节点经Pd()后符合要求，就放入队列，不符合就不放。
    5. 转到步骤2，循环执行
}

如果所有节点被扩展完了，没有找到答案就无解。
```
一、题型1：
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/7ae6b7c6-6513-4055-bbe2-9422c9af0ef2)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/db1fbe82-5968-4660-921f-f812e40dd200)
```c++
#include<iostream>
#include<queue>
using namespace std;
int n,m,day;
char mp[1005][1005];
struct Axi{
	int x,y,d;
}ax;
queue<Axi> qu;
int dirx[4]={0,1,0,-1};
int diry[4]={1,0,-1,0};

bool judge(int x,int y){
	if(x<1||x>n||y<1||y>m){ //超出边界了 
		return false;
	}else if(mp[x][y]=='g'){ //已经长过草了 
		return false;
	}
	return true; 
}

void BFS(){
	for(int i=1;i<=n;i++){  //扫描第0天的草，存入队列 
		for(int j=1;j<=m;j++){
			if(mp[i][j]=='g'){
				ax.x=i;
				ax.y=j;
				ax.d=0;
				qu.push(ax);
			}
		}
	}
	
	for(int i=1;i<=day;i++){  //开始长草 
	    int len=qu.size(); //获取当前队列的长度
	  	while(len){
	  		for(int j=0;j<4;j++){ //列举4个方向 
		 	   int tx=qu.front().x+dirx[j];
		     int ty=qu.front().y+diry[j];
		     if(judge(tx,ty)){
     		   ax.x=tx;
     		   ax.y=ty;
     		   ax.d=i;
     		   qu.push(ax);
     		   mp[tx][ty]='g'; 
		    }
		 }
		 qu.pop();
		 len--;
	  	}	 
	  }
	  	
	      
	}
int main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cin>>mp[i][j];
		}
	}
	cin>>day;
	
	BFS();
	
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			cout<<mp[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```

二、题二<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/4750c019-c0c1-428c-91cc-e75baa589bf4)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/bd61e18a-eff7-49b7-b493-b0815fc9ab2a)

```c++
#include<iostream>
#include<queue>
using namespace std;
int N,M;
bool mp[105][105];  //地图 
bool vis[105][105]; //判断是否走过
int x1,x2,y1,y2;   //起始坐标终点坐标 
int dirx[4]={0,1,0,-1}; //4个方向 
int diry[4]={1,0,-1,0};
struct Axi{  //push进队列的 
	int x,y,d;
}axi;
queue<Axi> qu;

bool judge(int x,int y){ 
	if(x<1||y<1||x>N||y>M){ //是否超出边界 
		return false;
	}else if(vis[x][y]||!mp[x][y]){ //是否已经走过或者遇到障碍 
		return false;
	}
	return true;
}

void BFS(){
	if(x1==x2&&y1==y2){ //起点和终点一样 
    	cout<<0;
    	return ;
    }
	axi.x=x1; //从起点开始 
	axi.y=y1;
	axi.d=0;
	qu.push(axi);
	vis[x1][y1]=true;
	
	int sum=1; //记录到了第几步 
	int flat=0;
	while(!qu.empty()){
	    int len=qu.size(); 
		while(len){
			for(int i=0;i<4;i++){
			  int tx=qu.front().x+dirx[i];
			  int ty=qu.front().y+diry[i];
			  if(tx==x2&&ty==y2){ //到终点了直接退出 
			    flat=1;
			  	cout<<sum;
			  	return ;
			  }
    	      if(judge(tx,ty)){
				axi.x=tx; 
				axi.y=ty;
				axi.d=sum;
				qu.push(axi);
				vis[tx][ty]=true;
			   }
		    }
          qu.pop();
  	      len--;
		}
		sum++;	
		
	}
	if(flat=0){  //到不了 
		cout<<-1; 
		return ;
	}
}

int main(){
	cin>>N>>M;
	for(int i=1;i<=N;i++){
		for(int j=1;j<=M;j++){
			cin>>mp[i][j];
		}
	}
	cin>>x1>>y1>>x2>>y2;
    
	
	BFS();
	
	return 0;
}
```

三、马的遍历<br>
![image](https://github.com/spesserta/My-note/assets/138494873/2de36491-2b34-42ac-b940-c6708194fadf)

```c++
#include<iostream>
#include<queue>
#include<iomanip>
using namespace std;
int n,m,x,y;
int mp[500][500]={0};  //地图 
bool vis[500][500];    //判断有没有走过该点 
int dirx[]={2,1,-1,-2,-2,-1,1,2}; //马走的8个方向 
int diry[]={1,2,2,1,-1,-2,-2,-1};
struct AXI{
	int x,y;
}ax;
queue<AXI> qu; 

bool judge(int x,int y){
	if(x<1||y<1||x>n||y>n){ //超出地图 
		return false;
	}
	if(vis[x][y]==true){  //已经走过该点 
		return false;
	}
	return true;
}

void BFS(int x,int y){
	ax.x=x; ax.y=y;
	qu.push(ax);
	int step=1;  //第几次搜索 

	while(!qu.empty()){
		int len=qu.size();
		while(len--){
			for(int i=0;i<8;i++){
			int tx=qu.front().x+dirx[i];
			int ty=qu.front().y+diry[i];
			if(judge(tx,ty)){ //判断有无超出边界，有无走过该点 
				ax.x=tx; ax.y=ty;
				qu.push(ax);
				mp[tx][ty]=step;
				vis[tx][ty]=true;
			}
		  }
		 qu.pop();
		}
		step++;
	}
}
int main(){
	cin>>n>>m>>x>>y;
	vis[x][y]=true; //初始化起始点 
	mp[x][y]=0;
	
	BFS(x,y);
	
	for(int i=1;i<=n;i++){ //输出 
		for(int j=1;j<=n;j++){
			if(vis[i][j]==false){ //马没走过的点输出-1 
				cout<<left<<setw(5)<<-1;
			}else{
				cout<<left<<setw(5)<<mp[i][j];
			}
			
		}
		cout<<endl;
	}
	return 0;
}
```
