# 深度优先搜索<br>
>通俗来说，深度优先搜索(dfs)就是一条路走到黑，当发现无路可走时退一步在选其他路径走，直到到达目标地址为止。<br>
通过经典的迷宫问题来理解：<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/5f3ef690-e23e-4d2d-9806-8c654bba772b)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/513b45b7-1f18-4b40-9bac-c2a91ead9bc2)
代码实现：<br>
```c++
#include<iostream>
using namespace std;
int n,m;
string maze[110]; //二维数组
bool vis[110][110];

bool in(int x,int y){ //判断是否越界 
	return 0<=x&&x<n&&y>=0&&y<m;
}
bool dfs(int x,int y){
	if(maze[x][y]=='T'){ //到终点了 
		return true;
	}
	vis[x][y]=1;  //走过这个点后vis记为1 
	maze[x][y]='m'; //走过后的路径用m表示方便显示出来
	
	int tx=x-1,ty=y; //往上走试试 
	//看看假如移动后在数组里面没越界并且没遇到墙并且没走过就移动，重新调用自己 
	if(in(tx,ty)&&maze[tx][ty]!='*'&&!vis[tx][ty]){  
		if(dfs(tx,ty)){
			return true;
		}
	} 
	
	tx=x,ty=y-1;//往左试试 
	//看看假如移动后在数组里面没越界并且没遇到墙并且没走过就移动，重新调用自己 
	if(in(tx,ty)&&maze[tx][ty]!='*'&&!vis[tx][ty]){  
		if(dfs(tx,ty)){
			return true;
		}
	} 
	 
    tx=x+1,ty=y;  //往下试试 
    //看看假如移动后在数组里面没越界并且没遇到墙并且没走过就移动，重新调用自己 
	if(in(tx,ty)&&maze[tx][ty]!='*'&&!vis[tx][ty]){  
		if(dfs(tx,ty)){
			return true;
		}
	} 
	tx=x,ty=y+1;  //往右试试 
	//看看假如移动后在数组里面没越界并且没遇到墙并且没走过就移动，重新调用自己 
	if(in(tx,ty)&&maze[tx][ty]!='*'&&!vis[tx][ty]){  
		if(dfs(tx,ty)){
			return true;
		}
	} 
	//如果四个方向都找不到就恢复 
	vis[x][y]=0;
	maze[x][y]='.';   //回到上一个位置
	return false;
} 
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>maze[i];
	}
	int x,y; //找出起始点 
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(maze[i][j]=='S'){
				x=i,y=j;  //给起始点赋值 
			}
		}
	}
	if(dfs(x,y)){ //能走通 
		for(int i=0;i<n;i++){
			cout<<maze[i]<<endl;
		}
	}else{  //没路可走 
		cout<<"No!!"<<endl;
	}
	return 0;
}
```
>当然可以简化一下代码，通过定义一个专门的方向变量dir即可<br>
`int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};  //从上方向开始逆时针依次探索`
完整代码：<br>
```c++
#include<iostream>
using namespace std;
int n,m;
string maze[110]; //二维数组
bool vis[110][110];
int dir[4][2]={{-1,0},{0,-1},{1,0},{0,1}};  //从上方向开始逆时针依次探索 

bool in(int x,int y){ //判断是否越界 
	return 0<=x&&x<n&&y>=0&&y<m;
}
bool dfs(int x,int y){
	if(maze[x][y]=='T'){  //抵达终点 
		return true; 
	}
	vis[x][y]=1;
	maze[x][y]='m';
	for(int i=0;i<4;i++){  //循环四次，四个方向依次尝试 
		int tx=x+dir[i][0];
		int ty=y+dir[i][1];
		if(in(tx,ty)&&maze[x][y]!='*'&&!vis[x][y]){
			if(dfs(tx,ty)){
				return true;
			}
		}
	}
	vis[x][y]=0;
	maze[x][y]='.';
	return false;
} 
int main(){
	cin>>n>>m;
	for(int i=0;i<n;i++){
		cin>>maze[i];
	}
	int x,y; //找出起始点 
	for(int i=0;i<n;i++){
		for(int j=0;j<m;j++){
			if(maze[i][j]=='S'){
				x=i,y=j;  //给起始点赋值 
			}
		}
	}
	if(dfs(x,y)){ //能走通 
		for(int i=0;i<n;i++){
			cout<<maze[i]<<endl;
		}
	}else{  //没路可走 
		cout<<"No!!"<<endl;
	}
	return 0;
}
```
## 一、象棋问题<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/200d81e8-cd58-4b67-9ca7-efbc4a62042a)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/364865d3-7659-4996-8045-32106d07acbd)
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/3dbfc38c-6351-4393-a08d-fc502f92fe29)
```c++
#include<iostream>
using namespace std;
char s[10][10]; //模拟一个棋盘 
int dir[8][2]={{2,1},{1,2},{-1,2},{-2,1},{-2,-1},{-1,-2},{1,-2},{2,-1}};//8个方向
bool f;  //判断有没有找到 
bool vis[10][10]; //标记路线有没有走过 
bool in(int x,int y){ //是否超出棋盘空间 
	return x>=0&&x<10&&y>=0&&y<9;
}
void dfs(int x,int y){
	vis[x][y]=true;
	if(f){   //已经找到了就不用找了 
	     return ;
	}
	if(s[x][y]=='T'){
	     f=true; //找到终点了停止 
	     return ;
	}
	for(int i=0;i<8;i++){  //假设走过8个方向 
		int tx=x+dir[i][0];
		int ty=y+dir[i][1];
		//判断假如方向走完后有没有超区件、碰墙、走过该路 
		if(in(tx,ty)&&s[tx][ty]!='#'&&!vis[tx][ty]){ 
			dfs(tx,ty);
		} 
	}
} 


int main(){
	for(int i=0;i<10;i++){ //输入初始值 
		cin>>s[i];
	}
	int x,y;
	cin>>x>>y; //输入起始点 
	for(int i=0;i<10;i++){  //搜索起始点 
		for(int j=0;j<9;j++){
			if(s[i][j]=='S'){
				x=i;
			    y=j;
			}
		}
	}
	dfs(x,y);
	if(f){
		cout<<"Yes"<<endl;
	}else{
		cout<<"No"<<endl;
	}
	return 0;
}
```
## 二、N皇后<br>
![image](https://github.com/spesserta/My-algorithm-note/assets/138494873/250e4d01-f867-423d-81c9-5922cb7a871f)
```c++
#include <iostream>
#include <cmath>
using namespace std;
int x[15]= {0};  //模拟一个棋盘，x[2]=3表示第二行皇后放在了第三列
int sum=0,n;
bool judge(int a) { //判断边界，是否会被其他皇后冲突
    for(int i = 1; i < a; i++) {
        if(abs(a-i)==abs(x[a]-x[i])) {//斜率等于正负一推得
            return false;
        } else if(x[a]==x[i]) {//两个皇后处于同一列
            return false;
        }
    }
    return true;
}

bool check(int a) { //检查是否到底
    if(a>n) //已经放完最后一个皇后了
    {
        sum++; //放置方法总数+1
        return true;
    } else{
        return false;
    }
}

void dfs(int a) {
    if(check(a)) {//检查是否放完
        return ;
    } else {
        for(int i = 1; i<=n; i++) {//在这一行上列举出每一列的情况
            x[a]=i;
            if(judge(a)) {//检查这里能不能放
                dfs(a+1);//能放就以此为基础放下一行的皇后
            } else {
                continue;
            };
        }
    };

}
int  main() {
    cin >> n;
    dfs(1);//从第一行开始
    cout << sum<< endl;
    return 0;
}
```



























